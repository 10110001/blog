[{"title":"Map的两个小扩展","date":"2018-09-02T16:00:00.000Z","path":"2018/09/03/Map的两个小扩展/","text":"前言 在以前，实现数据映射，我们利用给对象属性赋值，就像这样：12var mapping = Object.create( null );mapping[ key ] = value; ES6 的 Map/WeakMap 提供了更为便利及语义化的用法，功能更加强大，key 支持所有数据类型： 12const mapping = new Map;mapping.set( key, value ); 通过继承 Map/WeakMap，很容易扩展功能，以 Map 为例，本文讲述一个带 过期控制 和 持久化 能力的 Map 扩展。为表述方便，文中出现的代码均为伪代码，不可以直接运行。 过期控制 基本思路：每个 Map 中的 key，都可以指定其生命周期，在它生命终结后被自动清除。增加 set 方法的第三个参数，声明该 key 的生命周期，如果超过指定时间，再 get 时拿到的值为 undefined。伪代码如下： 123456789101112131415161718192021class MapStore extends Map&#123; constructor( ...args )&#123; super( ...args ); &#125; get( key )&#123; if( hasExpired( key ) )&#123; this.delete( key ); &#125; return super.get( key ); &#125; set( key, value, expires )&#123; if( typeof expires === 'number' )&#123; setExpires( key, expires ); &#125; return super.set( key, value ); &#125;&#125; 上面用了 setExpires、hasExpired 两个函数来做生命周期的设定和查询，除了设定和查询外，完整的功能还应该包括删除和清空，而这些方法刚好在原生 Map 中已有实现，所以过期时间的数据索性用一个 Map 来记录。 在 Map 的基础上，扩展 check 方法用于检查一个 key 是否过期： 12345678910111213141516class Expires extends Map &#123; check( key )&#123; const now = Date.now(); const expiredTime = this.get( key ); if( expiredTime )&#123; return expiredTime &gt; now; &#125;else&#123; return true; &#125; &#125; set( key, duration )&#123; return super.set( key, Date.now() + duration ); &#125;&#125; 把 Expires 应用到 MapStore 上，作为它附带的一个子对象 expiresControl： 1234567891011121314151617181920212223242526272829303132class MapStore extends Map &#123; constructor( ...args )&#123; super( ...args ); this.expiresControl = new Expires; &#125; get( key )&#123; if( !this.expiresControl.check( key ) )&#123; this.delete( key ); &#125; return super.get( key ); &#125; set( key, value, expires )&#123; if( typeof expires === 'number' )&#123; this.expiresControl.set( key, expires ); &#125; return super.set( key, value ); &#125; clear()&#123; this.expiresControl.clear(); return super.clear(); &#125; delete( key )&#123; this.expiresControl.delete( key ); return super.delete( key ); &#125;&#125; 到此为止，一个带有过期控制的 MapStore 就做完了，凡是过期的 key，在获取其 value 的时候总是拿到 undefined。 对 MapStore 做进一步扩展，把内存中的数据保存到一个 json 文件中，以供应用重启的时候得到复原，下例我们来实现一个带有这样的持久化能力的 FileStore。 持久化 基本思路：FileStore 除了实现 MapStore 的所有能力外，同时需要将数据体和本地的一个 json 文件同步，应用无论如何重启，都不会受到影响。FileStore 从 MapStore 继承而来，并扩展 json 文件同步的能力： 1234567891011121314151617181920212223242526272829303132333435363738const &#123; set, get &#125; = Map.prototype;class FileStore extends MapStore &#123; constructor( ...args )&#123; super( ...args ); &#125; async load( file )&#123; this.bindingFile = file; let data = await json.read( file ); for( let [ key, value, expires ] of data )&#123; set.call( this, key, value ); if( expires )&#123; set.call( this.expiresControl, key, expires ); &#125; &#125; &#125; async save()&#123; const content = []; for( let [ key, value ] of this )&#123; const expires = get.call( this.expiresControl, key ); const item = [ key, value ]; if( expires )&#123; item.push( expires ); &#125; content.push( item ); &#125; await json.write( this.bindingFile, content ); &#125;&#125; load() 方法实现从 json 文件中加载数据，并还原到当前实例中，save() 则相反，将当前实例所携带的数据，保存到 json 文件。需要注意的是，子对象 expiresControl 的数据也需要进行同步。 为了更加自动，可以把 save() 方法应用到对实例数据产生修改的所有方法当中： 1234567891011121314151617181920212223class FileStore extends MapStore &#123; ... async set( ...args )&#123; const result = super.set( ...args ); await this.save(); return result; &#125; async clear( ...args )&#123; const result = super.clear( ...args ); await this.save(); return result; &#125; async delete( ...args )&#123; const result = super.delete( ...args ); await this.save(); return result; &#125; ...&#125; 这样一来，写数据会同时写到内存和文件中，取数据则只从内存里取。 捆绑销售 为了方便使用，我把 MapStore 和 FileStore 打包在一起，用一个函数统一出口，包装了一个叫MapCache 的 npm 模块： 1234567891011121314151617181920const GlobalStore = new Map;exports.store = async ( name, fileName ) =&gt; &#123; if( GlobalStore.has( name ) )&#123; return GlobalStore.get( name ); &#125;else&#123; let store; if( fileName )&#123; store = new FileStore; await store.load( fileName ); &#125;else&#123; store = new MapStore; &#125; GlobalStore.set( name, store ); return store; &#125;&#125; store 函数以是否提供 fileName 参数来决定使用 MapStore 或者 FileStore，返回一个经过包装的 Map 对象，既可以像原生 Map 一样使用，又支持过期控制和持久化，用法详见 这里。 有什么用？ 该模块适合做一些小型的、临时性的用户交互行为信息存贮，举两个小例子： 1.登录验证码：服务端生成一个随机数，与即将登录的帐号映射，过期时间 n 分钟，随机数以图片形式发给浏览端，要求用户输入，以在后端做校验。 2.查看数的计算：用户在 n 分钟之间重复查看一篇文章，该文章的查看数只增加 1。可以利用该模块将文章 id 与查看用户做限时映射，如果已存在该用户，则查看数不增加。","tags":[]},{"title":"Map与Object的比较","date":"2018-03-19T16:00:00.000Z","path":"2018/03/20/Map与Object的比较/","text":"前言 Maps是es6里面新增的对象类型，创建形式如下：12// Creating new maplet myMap = new Map() 传递数组参数：123456789const myMap = new Map([ ['name', 'xiaoHong'], ['gender', '女'], ['age', 23]])console.log(myMap)// Output:// Map &#123; 'name' =&gt; 'xiaoHong', 'gender' =&gt; '女', 'age' =&gt; 23 &#125; 对象转化参数：1234567891011const myObj = &#123; subject: 'Math', level: '1', difficulty: 'Medium'&#125;const myMap = new Map(Object.entries(myObj))console.log(myMap)// Outputs:// Map &#123; 'subject' =&gt; 'Math', 'level' =&gt; '1', 'difficulty' =&gt; 'Medium' &#125; 快速了解maps我们知道Objects是用来以key-value对的形式存储数据的，Maps跟Objects很相似，当你往maps中存储数据的时候，其实也是key-value对的形式。 跟objects很相似，maps可以添加和删除属性，还可以检索values值，那么它们之间到底有什么区别呢？下面让我们来做个比较： Maps vs Objects简单总结如下： maps的keys可以是 任意数据类型，甚至包括 对象 和 函数，objects的keys只能是字符串 或者 symbol。 maps支持keys的排序并且是按照添加的顺序进行排列的, objects从es6开始只在JavaScript engines中才支持排序，在es6之前是不支持的。 maps的key-value对的数量获取更加容易，通过size属性即可，而objects要获取key-value对的数量需要先通过keys() 或者 values() 方法。 maps的遍历更加方便快捷，objects需要通过先获取数组形式的keys或者values集合,maps直接调用 forEach()即可，就像数组一样方便，也可以像objects一样使用 for...of 循环。forEach():12345678910111213const myMap = new Map()//添加属性值myMap.set('name', 'xiaoHong')myMap.set('gender', '女')myMap.set('age', '23')myMap.forEach((value, key) =&gt; &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`)&#125;)// Output:// 'name: xiaoHong'// 'gender: 女'// \"age: 23\" for…of和next():12345678910111213141516171819202122232425262728293031323334const myMap = new Map()//添加属性值myMap.set('name', 'xiaoHong')myMap.set('gender', '女')myMap.set('age', '23')// 也可以调用 keys() and values()const entriesIterator = myMap.entries()for (let item of entriesIterator) &#123; console.log(item)&#125;// Output:// [ 'name', 'xiaoHong' ] // [ 'gender', '女'] // [ 'age', '23' ]const keysIterator = myMap.keys()console.log(keysIterator.next().value)// Output:// 'name'console.log(keysIterator.next().value)// Output:// 'gender'const valuesIterator = myMap.values()console.log(valuesIterator.next().value)// Output:// 'xiaoHong'console.log(valuesIterator.next().value)// Output:// '女' maps对添加和删除key-value对的操作进行了性能上的优化，Objects则没有，所以使用maps可以帮助你提升代码的性能。 表格 Maps VS Objects 任意类型 KEY类型 String 或者 Symbol YES KEY排序 NO(ES5) YES 属性数量 NO YES 遍历 NO YES Add和Delete性能优化 NO","tags":[]},{"title":"2018阿里云部门年会","date":"2018-03-02T05:13:40.000Z","path":"2018/03/02/2018阿里云部门年会/","text":"2018年阿里云年会_现场2018年阿里云年会_现场2018年阿里云年会_现场2018年阿里云年会_现场2018年阿里云年会_现场2018年阿里云年会_现场2018年阿里云年会_现场2018年阿里云年会_现场2018年阿里云年会_现场","tags":[]},{"title":"2016年拓尔思杭州年会","date":"2017-03-28T04:52:06.000Z","path":"2017/03/28/2016年拓尔思杭州年会/","text":"2016年拓尔思年会_现场2016年拓尔思年会_现场2016年拓尔思年会_现场2016年拓尔思年会_五星级大酒店","tags":[]},{"title":"2016年拓尔思——浙江日报媒立方","date":"2017-03-28T02:53:53.000Z","path":"2017/03/28/2016年拓尔思年会/","text":"2016年春节_媒立方项目全体成员合照留念2016年春节_媒立方项目全体成员合照留念(于杭州.浙报大楼)","tags":[]},{"title":"我的第一个hexo博客","date":"2017-03-23T08:42:36.000Z","path":"2017/03/23/我的第一个hexo博客/","text":"大家好，我是新报到，请多多关照!","tags":[]}]