[{"title":"Map的两个小扩展","date":"2018-09-02T16:00:00.000Z","path":"2018/09/03/Map的两个小扩展/","text":"前言 在以前，实现数据映射，我们利用给对象属性赋值，就像这样：12var mapping = Object.create( null );mapping[ key ] = value; ES6 的 Map/WeakMap 提供了更为便利及语义化的用法，功能更加强大，key 支持所有数据类型： 12const mapping = new Map;mapping.set( key, value ); 通过继承 Map/WeakMap，很容易扩展功能，以 Map 为例，本文讲述一个带 过期控制 和 持久化 能力的 Map 扩展。为表述方便，文中出现的代码均为伪代码，不可以直接运行。 过期控制 基本思路：每个 Map 中的 key，都可以指定其生命周期，在它生命终结后被自动清除。增加 set 方法的第三个参数，声明该 key 的生命周期，如果超过指定时间，再 get 时拿到的值为 undefined。伪代码如下： 123456789101112131415161718192021class MapStore extends Map&#123; constructor( ...args )&#123; super( ...args ); &#125; get( key )&#123; if( hasExpired( key ) )&#123; this.delete( key ); &#125; return super.get( key ); &#125; set( key, value, expires )&#123; if( typeof expires === 'number' )&#123; setExpires( key, expires ); &#125; return super.set( key, value ); &#125;&#125; 上面用了 setExpires、hasExpired 两个函数来做生命周期的设定和查询，除了设定和查询外，完整的功能还应该包括删除和清空，而这些方法刚好在原生 Map 中已有实现，所以过期时间的数据索性用一个 Map 来记录。 在 Map 的基础上，扩展 check 方法用于检查一个 key 是否过期： 12345678910111213141516class Expires extends Map &#123; check( key )&#123; const now = Date.now(); const expiredTime = this.get( key ); if( expiredTime )&#123; return expiredTime &gt; now; &#125;else&#123; return true; &#125; &#125; set( key, duration )&#123; return super.set( key, Date.now() + duration ); &#125;&#125; 把 Expires 应用到 MapStore 上，作为它附带的一个子对象 expiresControl： 1234567891011121314151617181920212223242526272829303132class MapStore extends Map &#123; constructor( ...args )&#123; super( ...args ); this.expiresControl = new Expires; &#125; get( key )&#123; if( !this.expiresControl.check( key ) )&#123; this.delete( key ); &#125; return super.get( key ); &#125; set( key, value, expires )&#123; if( typeof expires === 'number' )&#123; this.expiresControl.set( key, expires ); &#125; return super.set( key, value ); &#125; clear()&#123; this.expiresControl.clear(); return super.clear(); &#125; delete( key )&#123; this.expiresControl.delete( key ); return super.delete( key ); &#125;&#125; 到此为止，一个带有过期控制的 MapStore 就做完了，凡是过期的 key，在获取其 value 的时候总是拿到 undefined。 对 MapStore 做进一步扩展，把内存中的数据保存到一个 json 文件中，以供应用重启的时候得到复原，下例我们来实现一个带有这样的持久化能力的 FileStore。 持久化 基本思路：FileStore 除了实现 MapStore 的所有能力外，同时需要将数据体和本地的一个 json 文件同步，应用无论如何重启，都不会受到影响。FileStore 从 MapStore 继承而来，并扩展 json 文件同步的能力： 1234567891011121314151617181920212223242526272829303132333435363738const &#123; set, get &#125; = Map.prototype;class FileStore extends MapStore &#123; constructor( ...args )&#123; super( ...args ); &#125; async load( file )&#123; this.bindingFile = file; let data = await json.read( file ); for( let [ key, value, expires ] of data )&#123; set.call( this, key, value ); if( expires )&#123; set.call( this.expiresControl, key, expires ); &#125; &#125; &#125; async save()&#123; const content = []; for( let [ key, value ] of this )&#123; const expires = get.call( this.expiresControl, key ); const item = [ key, value ]; if( expires )&#123; item.push( expires ); &#125; content.push( item ); &#125; await json.write( this.bindingFile, content ); &#125;&#125; load() 方法实现从 json 文件中加载数据，并还原到当前实例中，save() 则相反，将当前实例所携带的数据，保存到 json 文件。需要注意的是，子对象 expiresControl 的数据也需要进行同步。 为了更加自动，可以把 save() 方法应用到对实例数据产生修改的所有方法当中： 1234567891011121314151617181920212223class FileStore extends MapStore &#123; ... async set( ...args )&#123; const result = super.set( ...args ); await this.save(); return result; &#125; async clear( ...args )&#123; const result = super.clear( ...args ); await this.save(); return result; &#125; async delete( ...args )&#123; const result = super.delete( ...args ); await this.save(); return result; &#125; ...&#125; 这样一来，写数据会同时写到内存和文件中，取数据则只从内存里取。 捆绑销售 为了方便使用，我把 MapStore 和 FileStore 打包在一起，用一个函数统一出口，包装了一个叫MapCache 的 npm 模块： 1234567891011121314151617181920const GlobalStore = new Map;exports.store = async ( name, fileName ) =&gt; &#123; if( GlobalStore.has( name ) )&#123; return GlobalStore.get( name ); &#125;else&#123; let store; if( fileName )&#123; store = new FileStore; await store.load( fileName ); &#125;else&#123; store = new MapStore; &#125; GlobalStore.set( name, store ); return store; &#125;&#125; store 函数以是否提供 fileName 参数来决定使用 MapStore 或者 FileStore，返回一个经过包装的 Map 对象，既可以像原生 Map 一样使用，又支持过期控制和持久化，用法详见 这里。 有什么用？ 该模块适合做一些小型的、临时性的用户交互行为信息存贮，举两个小例子： 1.登录验证码：服务端生成一个随机数，与即将登录的帐号映射，过期时间 n 分钟，随机数以图片形式发给浏览端，要求用户输入，以在后端做校验。 2.查看数的计算：用户在 n 分钟之间重复查看一篇文章，该文章的查看数只增加 1。可以利用该模块将文章 id 与查看用户做限时映射，如果已存在该用户，则查看数不增加。","tags":[]},{"title":"2018阿里云部门年会","date":"2018-03-02T05:13:40.000Z","path":"2018/03/02/2018阿里云部门年会/","text":"2018年阿里云年会_现场2018年阿里云年会_现场2018年阿里云年会_现场2018年阿里云年会_现场2018年阿里云年会_现场2018年阿里云年会_现场2018年阿里云年会_现场2018年阿里云年会_现场2018年阿里云年会_现场","tags":[]},{"title":"2016年拓尔思杭州年会","date":"2017-03-28T04:52:06.000Z","path":"2017/03/28/2016年拓尔思杭州年会/","text":"2016年拓尔思年会_现场2016年拓尔思年会_现场2016年拓尔思年会_现场2016年拓尔思年会_五星级大酒店","tags":[]},{"title":"2016年拓尔思——浙江日报媒立方","date":"2017-03-28T02:53:53.000Z","path":"2017/03/28/2016年拓尔思年会/","text":"2016年春节_媒立方项目全体成员合照留念2016年春节_媒立方项目全体成员合照留念(于杭州.浙报大楼)","tags":[]},{"title":"我的第一个hexo博客","date":"2017-03-23T08:42:36.000Z","path":"2017/03/23/我的第一个hexo博客/","text":"大家好，我是新报到，请多多关照!","tags":[]}]